/*! For license information please see 227.turnkey.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkTurnkeySDK=self.webpackChunkTurnkeySDK||[]).push([[227],{227:(n,t,e)=>{e.r(t),e.d(t,{signWithApiKey:()=>i});var r=e(919),o=e(862);const i=async n=>{const{content:t,publicKey:e,privateKey:i}=n,u=await async function(n){const{uncompressedPrivateKeyHex:t,compressedPublicKeyHex:e}=n,o=(0,r.S)({uncompressedPrivateKeyHex:t,compressedPublicKeyHex:e});return await crypto.subtle.importKey("jwk",o,{name:"ECDSA",namedCurve:"P-256"},!1,["sign"])}({uncompressedPrivateKeyHex:i,compressedPublicKeyHex:e});return await async function(n){const{key:t,content:e}=n,r=await crypto.subtle.sign({name:"ECDSA",hash:"SHA-256"},t,(new TextEncoder).encode(e)),i=function(n){if(n.length%2!=0||0==n.length||n.length>132)throw new Error("Invalid IEEE P1363 signature encoding. Length: "+n.length);const t=c(n.subarray(0,n.length/2)),e=c(n.subarray(n.length/2,n.length));let r=0;const o=2+t.length+1+1+e.length;let i;return o>=128?(i=new Uint8Array(o+3),i[r++]=48,i[r++]=129,i[r++]=o):(i=new Uint8Array(o+2),i[r++]=48,i[r++]=o),i[r++]=2,i[r++]=t.length,i.set(t,r),r+=t.length,i[r++]=2,i[r++]=e.length,i.set(e,r),i}(new Uint8Array(r));return(0,o.pD)(i)}({key:u,content:t})};function c(n){let t=0;for(;t<n.length&&0==n[t];)t++;t==n.length&&(t=n.length-1);let e=0;128&~n[t]||(e=1);const r=new Uint8Array(n.length-t+e);return r.set(n.subarray(t),e),r}},919:(n,t,e)=>{function r(n,t){const e=btoa(function(n){let t="";for(let e=0;e<n.length;e+=1)t+=String.fromCharCode(n[e]);return t}(n)).replace(/=/g,"");return e.replace(/\+/g,"-").replace(/\//g,"_")}function o(){return BigInt("115792089210356248762697446949407573530086143415290314195533631308867097853951")}function i(){return BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b")}function c(n){return BigInt("0x"+function(n){let t="";for(let e=0;e<n.length;e++){const r=n[e].toString(16);t+=r.length>1?r:"0"+r}return t}(n))}function u(n,t){const e=n.toString(16),r=2*t;let o="";if(r<e.length)throw new Error(`cannot pack integer with ${e.length} hex chars into ${t} bytes`);return o="0".repeat(r-e.length),function(n){if(n.length%2!=0)throw new Error("Hex string length must be multiple of 2");const t=new Uint8Array(n.length/2);for(let e=0;e<n.length;e+=2)t[e/2]=parseInt(n.substring(e,e+2),16);return t}(o+e)}function s(n,t){return(n&BigInt(1)<<BigInt(t))!==BigInt(0)}function a(n){if(33!==n.length&&65!==n.length)throw new Error("Invalid length: point is not in compressed or uncompressed format");if((2===n[0]||3===n[0])&&33==n.length){const t=3===n[0],e=c(n.subarray(1,n.length)),a=o();if(e<BigInt(0)||e>=a)throw new Error("x is out of range");const l=function(n,t){const e=o();let r=function(n,t){if(t<=BigInt(0))throw new Error("p must be positive");const e=n%t;if(s(t,0)&&s(t,1)){const n=function(n,t,e){if(t===BigInt(0))return BigInt(1);let r=n;const o=t.toString(2);for(let t=1;t<o.length;++t)r=r*r%e,"1"===o[t]&&(r=r*n%e);return r}(e,t+BigInt(1)>>BigInt(2),t);if(n*n%t!==e)throw new Error("could not find a modular square root");return n}throw new Error("unsupported modulus value")}(((n*n+(e-BigInt(3)))*n+i())%e,e);return t!==s(r,0)&&(r=(e-r)%e),r}(e,t);return{kty:"EC",crv:"P-256",x:r(u(e,32)),y:r(u(l,32)),ext:!0}}if(4===n[0]&&65==n.length){const t=c(n.subarray(1,33)),e=c(n.subarray(33,65)),s=o();if(t<BigInt(0)||t>=s||e<BigInt(0)||e>=s||!function(n,t){const e=o(),r=((n*n+(e-BigInt(3)))*n+i())%e;return t**BigInt(2)%e===r}(t,e))throw new Error("invalid uncompressed x and y coordinates");return{kty:"EC",crv:"P-256",x:r(u(t,32)),y:r(u(e,32)),ext:!0}}throw new Error("invalid format")}e.d(t,{S:()=>g});var l=e(862);function g(n){const{uncompressedPrivateKeyHex:t,compressedPublicKeyHex:e}=n;let r;try{r=a((0,l.Ks)(e))}catch(n){throw new Error("unable to load API key: invalid public key. Did you switch your public and private key by accident? Is your public key a valid, compressed P-256 public key?")}return r.d=(0,l.el)(t,l.Ev),r}}}]);